     1                                  ;Author: Brian Huang
     2                                  ;Date: 3/2/23
     3                                  ;Purpose: Lab 4
     4                                  
     5                                  %include "CPsub64.inc"
     1                              <1> ; Last update: 2019/08/20
     2                              <1> 
     3                              <1> %ifndef CPSUB64
     4                              <1> %define CPSUB64
     5                              <1> 
     6                              <1> ; ------------------------------------------
     7                              <1> ; function prototypes
     8                              <1> ; ------------------------------------------
     9                              <1> extern Clearscr
    10                              <1> extern CloseFile
    11                              <1> extern Crlf
    12                              <1> extern ClearBuffer
    13                              <1> extern Delay
    14                              <1> extern DumpMem
    15                              <1> extern DumpCC
    16                              <1> extern DumpEflags
    17                              <1> extern DumpRegs
    18                              <1> extern IsDigit
    19                              <1> extern Mvcl
    20                              <1> extern FileOpen
    21                              <1> extern FileClose
    22                              <1> extern FileRead
    23                              <1> extern FileWrite
    24                              <1> extern ParseDecimal32
    25                              <1> extern ParseInteger32
    26                              <1> extern ParseDecimal64
    27                              <1> extern ParseInteger64
    28                              <1> extern ReadChar
    29                              <1> extern ReadDec
    30                              <1> extern ReadHex
    31                              <1> extern ReadInt
    32                              <1> extern ReadKey
    33                              <1> extern ReadString
    34                              <1> extern ReadStr
    35                              <1> extern Str_compare
    36                              <1> extern Str_copy
    37                              <1> extern Str_length
    38                              <1> extern StrLength
    39                              <1> extern Str_trim
    40                              <1> extern Str_ucase
    41                              <1> extern WriteBin
    42                              <1> extern WriteBinB
    43                              <1> extern WriteChar
    44                              <1> extern WriteDec
    45                              <1> extern WriteHex
    46                              <1> extern WriteHexDbl
    47                              <1> extern WriteHexB
    48                              <1> extern WriteInt
    49                              <1> extern WriteString
    50                              <1> ; ------------------------------------------
    51                              <1> 
    52                              <1> %endif
     6                                  %include "Macros_CPsub64.inc"
     1                              <1> ;--------------------------- MACROS ------------------------------------------
     2                              <1> ; Change Log:
     3                              <1> ; 02-06-21 CP Rename ifndef for Exit from CPExit to Exit, update mShowRegister
     4                              <1> ;
     5                              <1> ;
     6                              <1> ;-----------------------------------------------------------------------------
     7                              <1> %ifndef MACRO_CPSUB64
     8                              <1> %define MACRO_CPSUB64
     9                              <1> 
    10                              <1> %define STDIN  0
    11                              <1> %define STDOUT 1
    12                              <1> %define STDERR 2
    13                              <1> 
    14                              <1> %define TAB 09h
    15                              <1> %define NL 0Ah
    16                              <1> 
    17                              <1> ; define the timespec structure used in nanosleep
    18                              <1> struc timespec
    19 00000000 <res 00000004>      <1>      tv_sec: resd 1
    20 00000004 <res 00000004>      <1>      tv_nsec: resd 1
    21                              <1> endstruc
    22                              <1> 
    23                              <1> 
    24                              <1> ; Synonym for NASM invoke
    25                              <1> %ifnmacro INVOKE
    26                              <1> %macro INVOKE 1-*.nolist
    27                              <1>      %rep %0 - 1
    28                              <1>      %rotate -1
    29                              <1>      push qword %1
    30                              <1>      %endrep
    31                              <1>      %rotate -1
    32                              <1>      call %1
    33                              <1>      add rsp, ( %0 - 1 ) * 8
    34                              <1> %endmacro
    35                              <1> %endif
    36                              <1> 
    37                              <1> 
    38                              <1> %ifnmacro mWrite
    39                              <1> ;------------------------------------------------------
    40                              <1> %macro mWrite 1.nolist
    41                              <1> ;
    42                              <1> ; Writes a string literal to standard output.
    43                              <1> ; Receives: a string enclosed in single or double 
    44                              <1> ;   quotes (null terminator not required).
    45                              <1> ;------------------------------------------------------
    46                              <1> segment .data
    47                              <1> 	%%string: db %1, 0
    48                              <1> segment .text
    49                              <1> 	push	rdx
    50                              <1> 	mov	rdx,%%string
    51                              <1>  	call	WriteString
    52                              <1>  	pop	rdx
    53                              <1> %endmacro
    54                              <1> %endif
    55                              <1> 
    56                              <1> 
    57                              <1> %ifnmacro mWriteSpace
    58                              <1> ;------------------------------------------------------
    59                              <1> %macro mWriteSpace 0-1.nolist 1
    60                              <1> ;
    61                              <1> ; Writes one or more spaces to standard output.
    62                              <1> ; Receives: an integer specifying the number of spaces.
    63                              <1> ;   If count is blank, a single space is written.
    64                              <1> ;------------------------------------------------------
    65                              <1> segment .data
    66                              <1> %%spaces: times %1 db ' '
    67                              <1> 	db 0
    68                              <1> segment .text
    69                              <1> 	push	rdx
    70                              <1> 	mov	rdx, %%spaces
    71                              <1> 	call	WriteString
    72                              <1> 	pop	rdx
    73                              <1> %endmacro
    74                              <1> %endif
    75                              <1> 
    76                              <1> 
    77                              <1> %ifnmacro mShowRegister
    78                              <1> ;---------------------------------------------------
    79                              <1> %macro mShowRegister 2.nolist
    80                              <1> ;
    81                              <1> ; Displays a 64-bit register name and its contents.
    82                              <1> ; Receives: the register string name, the register.
    83                              <1> ; Returns:  nothing
    84                              <1> ;---------------------------------------------------
    85                              <1> segment .data
    86                              <1> %%tempStr: db "  ", %1,": ",0
    87                              <1> 
    88                              <1> segment .text
    89                              <1> 	push	rax		; save reg	
    90                              <1> 	push	rdx 		; save reg
    91                              <1> 	mov	rdx, %%tempStr	; display the register name
    92                              <1> 	call	WriteString
    93                              <1> 	pop	rdx		; restore reg
    94                              <1> 	mov	rax, %2		; display the reg contents in hex
    95                              <1> 	call	WriteHex
    96                              <1> 	pop	rax             ; restore reg
    97                              <1> %endmacro
    98                              <1> %endif
    99                              <1> 
   100                              <1> 
   101                              <1> %ifnmacro ShowFlag
   102                              <1> ;---------------------------------------------------------------------
   103                              <1> %macro ShowFlag 2.nolist
   104                              <1> ;
   105                              <1> ; Helper macro.
   106                              <1> ; Display a single CPU flag value
   107                              <1> ; Directly accesses the eflags variable in Along32.asm
   108                              <1> ; (This macro cannot be placed in Macros.inc)
   109                              <1> ;---------------------------------------------------------------------
   110                              <1> segment .data
   111                              <1> %%flagStr: db "  ",%1, "="
   112                              <1> %%flagVal: db 0,0
   113                              <1> 
   114                              <1> segment .text
   115                              <1> 	push rax
   116                              <1> 	push rdx
   117                              <1> 	mov  rax, qword [eflags]	; retrieve the flags
   118                              <1> 	mov  byte [%%flagVal],'1'
   119                              <1> 	shr  rax, %2			; shift into carry flag
   120                              <1> 	jc   %%L1
   121                              <1> 	mov  byte [%%flagVal],'0'
   122                              <1> %%L1:
   123                              <1> 	mov  rdx, %%flagStr	; display flag name and value
   124                              <1> 	call WriteString
   125                              <1> 	pop  rdx
   126                              <1> 	pop  rax
   127                              <1> %endmacro
   128                              <1> %endif
   129                              <1> 
   130                              <1> 
   131                              <1> %ifnmacro ShowCC
   132                              <1> ;---------------------------------------------------------------------
   133                              <1> %macro ShowCC 2.nolist
   134                              <1> ;
   135                              <1> ; Helper macro.
   136                              <1> ; Display a single Condition Code Eflag name and value
   137                              <1> ; Directly accesses the eflags variable.
   138                              <1> ; 
   139                              <1> ;---------------------------------------------------------------------
   140                              <1> segment .data
   141                              <1> %%flagStr: db "  ",%1," : "    	; flag name plus = sign
   142                              <1> %%flagVal: db 0,0         	; flag value if 0 or 1, plus NULL
   143                              <1> 
   144                              <1> segment .text
   145                              <1> 	push rax  		; save reg
   146                              <1> 	push rdx		; save reg
   147                              <1> 	mov  rax, qword [eflags]	; retrieve the flags
   148                              <1> 	mov  byte [%%flagVal],'1'	; ON
   149                              <1> 	shr  rax, %2		; shift into carry flag
   150                              <1> 	jc   %%L1
   151                              <1> 	mov  byte [%%flagVal],'0'	; OFF
   152                              <1> %%L1:
   153                              <1> 	mov  rdx, %%flagStr	; display flag name and value
   154                              <1> 	call WriteString
   155                              <1> 	call Crlf		; line feed
   156                              <1> 	pop  rdx		; restore reg
   157                              <1> 	pop  rax		; restore reg
   158                              <1> %endmacro
   159                              <1> %endif
   160                              <1> 
   161                              <1> 
   162                              <1> 
   163                              <1> %ifnmacro CheckInit
   164                              <1> ;-------------------------------------------------------------
   165                              <1> %macro CheckInit 0.nolist
   166                              <1> ;
   167                              <1> ; Helper macro
   168                              <1> ; Check to see if the console handles have been initialized
   169                              <1> ; If not, initialize them now.
   170                              <1> ;-------------------------------------------------------------
   171                              <1> 	cmp byte [InitFlag],0
   172                              <1> 	jne %%exit
   173                              <1> 	mov byte [InitFlag],1
   174                              <1> 	call BufferFlush
   175                              <1> %%exit:
   176                              <1> %endmacro
   177                              <1> %endif
   178                              <1> 
   179                              <1> 
   180                              <1> %ifnmacro SaveRegs
   181                              <1> ;-------------------------------------------------------------
   182                              <1> %macro SaveRegs 0.nolist
   183                              <1> ;
   184                              <1> ; Convenience macro
   185                              <1> ; Save Registers
   186                              <1> ; PUSH the 16 general purpose regs to the stack.
   187                              <1> ;-------------------------------------------------------------
   188                              <1>        push rax
   189                              <1>        push rbx 
   190                              <1>        push rcx
   191                              <1>        push rdx
   192                              <1>        push rsi
   193                              <1>        push rdi
   194                              <1>        push rbp
   195                              <1>        push rsp
   196                              <1>        push r8 	
   197                              <1>        push r9  
   198                              <1>        push r10
   199                              <1>        push r11
   200                              <1>        push r12
   201                              <1>        push r13
   202                              <1>        push r14
   203                              <1>        push r15
   204                              <1> %%exit:
   205                              <1> %endmacro
   206                              <1> %endif
   207                              <1> 
   208                              <1> %ifnmacro RestoreRegs
   209                              <1> ;-------------------------------------------------------------
   210                              <1> %macro RestoreRegs 0.nolist
   211                              <1> ;
   212                              <1> ; Convenience macro
   213                              <1> ; Restore Registers
   214                              <1> ; POP the 16 general purpose regs from the stack.
   215                              <1> ;-------------------------------------------------------------
   216                              <1> 	pop r15
   217                              <1> 	pop r14
   218                              <1> 	pop r13
   219                              <1>      	pop r12
   220                              <1> 	pop r11 
   221                              <1> 	pop r10
   222                              <1>      	pop r9 
   223                              <1>      	pop r8 
   224                              <1> 	pop rsp
   225                              <1>       	pop rbp 
   226                              <1>       	pop rdi
   227                              <1>       	pop rsi
   228                              <1>       	pop rdx
   229                              <1>       	pop rcx 
   230                              <1>       	pop rbx
   231                              <1>       	pop rax
   232                              <1> %%exit:
   233                              <1> %endmacro
   234                              <1> %endif
   235                              <1> 
   236                              <1> ; Termination Macro
   237                              <1> ;-------------------------------------------------------------
   238                              <1> ;
   239                              <1> ; Convenience macro
   240                              <1> ; Exit to operating system under Linux.
   241                              <1> ;-------------------------------------------------------------
   242                              <1> %ifnmacro Exit
   243                              <1> %macro Exit 0.nolist  
   244                              <1>      mov rax, 60
   245                              <1>      xor rdi, rdi
   246                              <1>      syscall
   247                              <1> %%exit:
   248                              <1> %endmacro
   249                              <1> %endif
   250                              <1> 
   251                              <1> ; Termination Macro
   252                              <1> %ifnmacro CPexit
   253                              <1> ;-------------------------------------------------------------
   254                              <1> ;
   255                              <1> ; Convenience macro
   256                              <1> ; Exit to operating system under Linux.
   257                              <1> ;-------------------------------------------------------------
   258                              <1> %macro CPexit 0-1.nolist  
   259                              <1>      mov rax, 60
   260                              <1>      xor rdi, rdi
   261                              <1>      syscall
   262                              <1> %%exit:
   263                              <1> %endmacro
   264                              <1> %endif
   265                              <1> 
   266                              <1> %endif  ;End of Macro Definitions
     7                                  global main
     8                                  
     9                                  section .text
    10                                  main: 
    11                                  
    12                                  
    13                                  start:
    14                                  ;print the first message
    15 00000000 B801000000              mov rax,1
    16 00000005 BF01000000              mov rdi,1
    17 0000000A 48BE-                   mov rsi,addMessage
    17 0000000C [0000000000000000] 
    18 00000014 BA33000000              mov rdx,addMessageLen
    19 00000019 0F05                    syscall
    20                                  
    21                                  
    22                                  
    23                                  
    24                                  ;print second msg
    25 0000001B B801000000              mov rax,1
    26 00000020 BF01000000              mov rdi,1
    27 00000025 48BE-                   mov rsi,secondMessage
    27 00000027 [3300000000000000] 
    28 0000002F BA1E000000              mov rdx,secondMessageLen
    29 00000034 0F05                    syscall
    30                                  
    31                                  ;get Input
    32 00000036 BAFF000000              mov rdx, 255
    33 0000003B 48B9-                   mov rcx, userInput
    33 0000003D [0000000000000000] 
    34 00000045 BB00000000              mov rbx, 0
    35 0000004A B803000000              mov rax, 3
    36 0000004F CD80                    int 80h
    37                                  
    38                                  ;convert Integer to string
    39 00000051 48BA-                   mov rdx, userInput
    39 00000053 [0000000000000000] 
    40 0000005B B9FF000000              mov rcx, 255
    41 00000060 E8(00000000)            call ParseInteger64
    42                                  
    43                                  ;save the result
    44 00000065 4989C7                  mov r15,rax
    45                                  
    46                                  
    47                                  ;duplicate so that this number is saved after calculations
    48 00000068 4D89FD                  mov r13,r15
    49                                  
    50                                  ;print message asking for second input
    51 0000006B B801000000              mov rax, 1
    52 00000070 BF01000000              mov rdi,1
    53 00000075 48BE-                   mov rsi, thirdMessage
    53 00000077 [5100000000000000] 
    54 0000007F BA1F000000              mov rdx, thirdMessageLen
    55 00000084 0F05                    syscall
    56                                  
    57                                  ;get second input
    58 00000086 BAFF000000              mov rdx,255
    59 0000008B 48B9-                   mov rcx, userInput
    59 0000008D [0000000000000000] 
    60 00000095 BB00000000              mov rbx,0
    61 0000009A B803000000              mov rax,3
    62 0000009F CD80                    int 80h
    63                                  
    64                                  ;convert Integer to string
    65 000000A1 48BA-                   mov rdx,userInput
    65 000000A3 [0000000000000000] 
    66 000000AB B9FF000000              mov rcx, 255
    67 000000B0 E8(00000000)            call ParseInteger64
    68                                  
    69                                  ;save the number
    70 000000B5 4989C6                  mov r14,rax
    71                                  
    72                                  ;print operator message
    73 000000B8 B801000000              mov rax,1
    74 000000BD BF01000000              mov rdi,1
    75 000000C2 48BE-                   mov rsi,operatorMsg
    75 000000C4 [7100000000000000] 
    76 000000CC BA25000000              mov rdx,operatorMsgLen
    77 000000D1 0F05                    syscall
    78                                  
    79                                  ;get operatoor input
    80 000000D3 48BA-                   mov rdx,userInput
    80 000000D5 [0000000000000000] 
    81 000000DD B9FF000000              mov rcx,255
    82 000000E2 E8(00000000)            call ReadString
    83                                  
    84                                  
    85 000000E7 50                      push rax
    86 000000E8 52                      push rdx
    87                                  
    88                                  
    89 000000E9 E847000000              call math
    90                                  
    91                                  
    92 000000EE 58                      pop rax
    93 000000EF 5A                      pop rdx
    94                                  
    95                                  ;continue?
    96 000000F0 48BA-                   mov rdx, continue
    96 000000F2 [A200000000000000] 
    97 000000FA E8(00000000)            call WriteString
    98 000000FF E8(00000000)            call Crlf
    99 00000104 48BA-                   mov rdx,userInput
    99 00000106 [0000000000000000] 
   100 0000010E B9FF000000              mov rcx,255
   101 00000113 E8(00000000)            call ReadString
   102 00000118 480FB71425-             movzx rdx, word [userInput];
   102 0000011D [00000000]         
   103 00000121 4883FA79                cmp rdx,'y'
   104 00000125 0F84D5FEFFFF            je start
   105                                  
   106                                  
   107                                  
   108                                  
   109                                  exit:
   110                                  
   111                                  ;exit
   112 0000012B B83C000000              mov rax, 60
   113 00000130 4831FF                  xor rdi, rdi
   114 00000133 0F05                    syscall
   115                                  
   116                                  
   117                                  ;math function
   118                                  math:
   119                                  
   120                                  ;prologue
   121 00000135 55                      push rbp
   122 00000136 4889E5                  mov rbp,rsp;set pointer to current top on the stack
   123 00000139 53                      push rbx
   124                                  
   125                                  
   126                                  ;perform calculations
   127                                  
   128                                  
   129                                  
   130 0000013A 480FB71425-             movzx rdx, word [userInput]
   130 0000013F [00000000]         
   131 00000143 4883FA2B                cmp rdx, '+' ;2bh in hex
   132 00000147 7467                    je addition;equALS
   133                                  
   134 00000149 4883FA2D                cmp rdx, '-'
   135 0000014D 7414                    je subtraction
   136                                  
   137 0000014F 4883FA2F                cmp rdx, '/'
   138 00000153 0F84F4000000            je division
   139                                  
   140 00000159 4883FA2A                cmp rdx, '*'
   141 0000015D 0F849A000000            je multiplication
   142                                  
   143                                  
   144                                  
   145                                  
   146                                  
   147                                  subtraction:
   148 00000163 4D29F7                  sub r15,r14
   149 00000166 48BA-                   mov rdx,resultMessage
   149 00000168 [9600000000000000] 
   150 00000170 E8(00000000)            call WriteString
   151 00000175 4C89E8                  mov rax,r13
   152 00000178 E8(00000000)            call WriteDec
   153 0000017D 48BA-                   mov rdx,userInput
   153 0000017F [0000000000000000] 
   154 00000187 E8(00000000)            call WriteString
   155 0000018C 4C89F0                  mov rax,r14
   156 0000018F E8(00000000)            call WriteDec
   157 00000194 48BA-                   mov rdx,equals
   157 00000196 [9F00000000000000] 
   158 0000019E E8(00000000)            call WriteString
   159 000001A3 4C89F8                  mov rax,r15
   160 000001A6 E8(00000000)            call WriteInt
   161 000001AB E90C010000              jmp result
   162                                  
   163                                  addition:
   164                                  
   165                                  ;do da addition
   166 000001B0 4D01F7                  add r15,r14
   167 000001B3 48BA-                   mov rdx,resultMessage
   167 000001B5 [9600000000000000] 
   168 000001BD E8(00000000)            call WriteString
   169 000001C2 4C89E8                  mov rax,r13
   170 000001C5 E8(00000000)            call WriteDec
   171 000001CA 48BA-                   mov rdx,userInput
   171 000001CC [0000000000000000] 
   172 000001D4 E8(00000000)            call WriteString
   173 000001D9 4C89F0                  mov rax,r14
   174 000001DC E8(00000000)            call WriteDec
   175 000001E1 48BA-                   mov rdx,equals
   175 000001E3 [9F00000000000000] 
   176 000001EB E8(00000000)            call WriteString
   177 000001F0 4C89F8                  mov rax,r15
   178 000001F3 E8(00000000)            call WriteInt
   179 000001F8 E9BF000000              jmp result
   180                                  
   181                                  multiplication:
   182 000001FD 4C89F8                  mov rax,r15
   183 00000200 49F7EE                  imul r14
   184 00000203 4989C7                  mov r15,rax;save the result back to r15
   185 00000206 48BA-                   mov rdx,resultMessage
   185 00000208 [9600000000000000] 
   186 00000210 E8(00000000)            call WriteString
   187 00000215 4C89E8                  mov rax,r13
   188 00000218 E8(00000000)            call WriteDec
   189 0000021D 48BA-                   mov rdx,userInput
   189 0000021F [0000000000000000] 
   190 00000227 E8(00000000)            call WriteString
   191 0000022C 4C89F0                  mov rax,r14
   192 0000022F E8(00000000)            call WriteDec
   193 00000234 48BA-                   mov rdx,equals
   193 00000236 [9F00000000000000] 
   194 0000023E E8(00000000)            call WriteString
   195 00000243 4C89F8                  mov rax,r15
   196 00000246 E8(00000000)            call WriteInt
   197 0000024B EB6F                    jmp result
   198                                  
   199                                  division:
   200 0000024D 4C89F8                  mov rax,r15
   201 00000250 BA00000000              mov rdx,0
   202 00000255 49F7FE                  idiv dword r14
   202          ******************       warning: register size specification ignored [-w+other]
   203 00000258 4989C7                  mov r15,rax
   204 0000025B 4989D4                  mov r12,rdx
   205 0000025E 48BA-                   mov rdx,resultMessage
   205 00000260 [9600000000000000] 
   206 00000268 E8(00000000)            call WriteString
   207 0000026D 4C89E8                  mov rax,r13
   208 00000270 E8(00000000)            call WriteDec
   209 00000275 48BA-                   mov rdx,userInput
   209 00000277 [0000000000000000] 
   210 0000027F E8(00000000)            call WriteString
   211 00000284 4C89F0                  mov rax,r14
   212 00000287 E8(00000000)            call WriteDec
   213 0000028C 48BA-                   mov rdx,equals
   213 0000028E [9F00000000000000] 
   214 00000296 E8(00000000)            call WriteString
   215 0000029B 4C89F8                  mov rax,r15
   216 0000029E E8(00000000)            call WriteInt
   217 000002A3 48BA-                   mov rdx,r
   217 000002A5 [B300000000000000] 
   218 000002AD E8(00000000)            call WriteString
   219 000002B2 4C89E0                  mov rax,r12
   220 000002B5 E8(00000000)            call WriteDec
   221                                  
   222 000002BA EB00                    jmp result
   223                                  
   224                                  result:
   225                                  ;display answer 
   226                                  
   227                                  ;result
   228                                  
   229                                  
   230 000002BC E8(00000000)            call Crlf
   231                                  
   232                                  ;epilogue
   233 000002C1 5B                      pop rbx
   234 000002C2 5D                      pop rbp 
   235 000002C3 C3                      ret
   236                                  
   237                                  
   238                                  
   239                                  ;get Input
   240                                  
   241                                  section .data
   242 00000000 596F752077696C6C20-     addMessage: db "You will be asked for two numbers and an operator.",0ah	;first message
   242 00000009 62652061736B656420-
   242 00000012 666F722074776F206E-
   242 0000001B 756D6265727320616E-
   242 00000024 6420616E206F706572-
   242 0000002D 61746F722E0A       
   243                                  addMessageLen: equ($-addMessage) 								;get length of firstMessage									;getLength of Division Message
   244 00000033 506C6561736520656E-     secondMessage: db "Please enter the first number",0ah 				;second message
   244 0000003C 746572207468652066-
   244 00000045 69727374206E756D62-
   244 0000004E 65720A             
   245                                  secondMessageLen: equ($-secondMessage)								;get length of secondMessage
   246 00000051 506C6561736520656E-     thirdMessage: db "Please enter the second number",0ah			;third message
   246 0000005A 746572207468652073-
   246 00000063 65636F6E64206E756D-
   246 0000006C 6265720A           
   247                                  thirdMessageLen:equ($-thirdMessage)								;get the length of the third message
   248 00000070 0A                      lineBreak: db "",0ah
   249                                  lineBreakLen: equ($-lineBreak)
   250 00000071 506C6561736520656E-     operatorMsg: db "Please enter an arithmetic operator",0,0ah
   250 0000007A 74657220616E206172-
   250 00000083 6974686D6574696320-
   250 0000008C 6F70657261746F7200-
   250 00000095 0A                 
   251                                  operatorMsgLen: equ($-operatorMsg)
   252 00000096 526573756C743A000A      resultMessage:db"Result:",0,0ah
   253 0000009F 3D000A                  equals:db '=',0,0ah
   254                                  equalslen: equ($-equals)
   255 000000A2 436F6E74696E75653F-     continue: db "Continue? y/n",0,0ah
   255 000000AB 20792F6E000A       
   256                                  
   257 000000B1 7900                    y: db  "y",0
   258 000000B3 2072656D61696E6465-     r: db " remainder:",0
   258 000000BC 723A00             
   259                                  section .bss
   260 00000000 <res 000000FF>          userInput: resb 255												;reserves 255 bytes
